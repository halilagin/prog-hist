
<!--
classical parallel coordinates
see: https://bl.ocks.org/jasondavies/1341281

programatic brushing
see: http://bl.ocks.org/timelyportfolio/5c136de85de1c2abb6fc

ordinal scale brushing
see: http://bl.ocks.org/chrisbrich/4173587

multiple brushes
see: http://bl.ocks.org/ludwigschubert/0236fa8594c4b02711b2606a8f95f605
http://bl.ocks.org/jssolichin/54b4995bd68275691a23

-->



<!DOCTYPE html>
<head>
<meta charset="utf-8">
<style>


  /*.background{*/
    /*visibility: visible !important;*/
    /*fill:#dedede;*/
  /*}*/


  /*.extent{*/
    /*visibility: visible !important;*/
    /*fill:#000;*/
  /*}*/


  /*.resize rect{*/
    /*visibility: visible !important;*/
    /*fill:#00ab00;*/
  /*}*/

  svg {
    font: 10px sans-serif;
  }

  .background path {
    fill: none;
    stroke: #ddd;
    shape-rendering: crispEdges;
  }

  .foreground path {
    fill: none;
    stroke: steelblue;
  }

  .brush .extent {
    fill-opacity: .3;
    stroke: #fff;
    shape-rendering: crispEdges;
  }

  .axis line,
  .axis path {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
  }

  .axis text {
    text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
    cursor: move;
  }

</style>
<script
  src="https://code.jquery.com/jquery-3.2.1.min.js"
  integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
  crossorigin="anonymous"></script>
</head>
<body>

<div>
  <button id="sepal_w_brush_btn">show brush</button>

</div>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

  var margin = {top: 30, right: 10, bottom: 10, left: 10};
  var width = 960 - margin.left - margin.right;
  var height = 500 - margin.top - margin.bottom;
  var underHeightLength=200;
  var x = d3.scale.ordinal().rangePoints([0, width], 1);
  var y = {};


  var dragging = {};

  var line = d3.svg.line(),
    axis = d3.svg.axis().orient("left"),
    background,
    foreground;

  var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom+underHeightLength)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");




  /*
    estcorrbrush:start
   */
  var dimscales={};
  var corrBrushes={};
  var estcorrbrush_panels;
  var estbrushInstance;
  var pc_petal_len_scale = d3.scale.linear().domain([1, 7.7]).range([-0.99, 0.99]);
  var pc_petal_len_scale_r = d3.scale.linear().domain([-0.99, 0.99]).range([1, 7.5]);

  var pc_petal_w_scale = d3.scale.linear().domain([0, 2.6]).range([-0.99, 0.99]);
  var pc_petal_w_scale_r = d3.scale.linear().domain([-0.99, 0.99]).range([0, 2.6]);

  var estcorr_xscale = d3.scale.linear().domain([-0.99, 0.99]).range([0, 70]);
  var estcorr_yscale = d3.scale.linear().domain([-0.99, 0.99]).range([70, 0]);
  var estcorr_rscale = d3.scale.linear().domain([0, 1]).range([0, 35]);
  var estcorr_line = d3.svg.line()
    .x(function(d) { return estcorr_xscale(d.x); })
    .y(function(d) { return estcorr_yscale(d.y); });

  /*
   estcorrbrush:end
   */

  /*
    sigma slider brushes
   */

  var sigmaSlider_xScale = d3.scale.linear().domain([0,3]).range([0,70]);
  var sigmaSlider_rxScale = d3.scale.linear().domain([0,70]).range([0,3]);

  var sigmaSlider_axis = d3.svg.axis().scale(sigmaSlider_xScale);

  function position(d) {
    var v = dragging[d];
    return v == null ? x(d) : v;
  }

  function transition(g) {
    return g.transition().duration(500);
  }

  // Returns the path for a given data point.
  function path(d) {
    return line(dimensions.map(function(p) { return [position(p), y[p](d[p])]; }));
  }


  function brushstart() {
    var dimidx=dimensionBrush_dim_idx(this);
      console.log("brushstart", dimidx);

    if (d3.event.sourceEvent===undefined ||  d3.event.sourceEvent===null) {
        console.log("dim brushing from corrbrush or sigmabrush");
      return;
    } else {
        //brushing from the dimension axis.
      console.log($(d3.event.sourceEvent.target).parent().attr("class"));
    }

    if (d3.event.sourceEvent.stopPropagation===undefined || d3.event.sourceEvent.stopPropagation===null)
      return;
    d3.event.sourceEvent.stopPropagation();
  }

  function dimensionBrush_dim_idx(obj){
    var dim_ = $(obj).parent().attr("class").split(" ")[1].substring("dimension_".length);
    var brush_clazz = $(obj).attr("class").split(" ")[1];
    var brushIdx=  +brush_clazz.substring(brush_clazz.lastIndexOf("_")+1) -1;

    return {"dim":dim_, "idx":brushIdx};
  }

  function brushend() {
    var dimidx = dimensionBrush_dim_idx(this);
    var lastBrush = y[dimidx.dim].brushes[dimidx.idx];
    var ext = lastBrush.extent();
    console.log(lastBrush);
    if ( ext[0]!= ext[1]){
     // console.log("brushend.dimension:",ext, dim_,lastBrush.empty(), d3.event.type);
      //var brush_ = d3.svg.brush().y(y[dim_]).on("brushstart", brushstart).on("brush", brush).on("brushend",brushend);
      //y[dim_].brushes.push( brush_);
      //d3.select(".dimension_"+dim_).call(brush_);
    }

//    var this_extent = d3.select(this);
//    console.log("brushend.this_extent",this_extent);

  }

  function findDimensionIndexByDimName(dimname){
      for (var i=0;i<dimensions.length;i++){
          if (dimensions[i]===dimname)
              return i;
      }
      return -1;
  }

  // Handles a brush event, toggling the display of foreground lines.
  function brush() {
    if (d3.event.type === "brush" && d3.event.mode === "resize") {

      var classes_ = $(this).parent().attr("class").split(" ");
      var dimclass = "";
      for (var i = 0; i < classes_.length; i++) {
        if (classes_[i] && classes_[i].startsWith("dimension_")) {
          dimclass = classes_[i].substring("dimension_".length);
          break;
        }
      }
      var dimIdx = findDimensionIndexByDimName(dimclass);
      var corrbrush_key = dimensions[dimIdx-1] + "___" + dimensions[dimIdx];

      //var brush_ = y[p].brush || y[p]["brushes"][0];

      //TODO do sigma reverse estimation. from vertical resize to sigmaslider.
//      var ex = brush_.extent();
//      var range_ = (ex[1]-ex[0])/2.0;
//      var muvar = estcorr_estimateMuVariance(corrbrush_key);
//      var sigmaFactor = range_/Math.sqrt(muvar.variance);

//      console.log("sigmaFactor", sigmaFactor);

//      corrBrushes[corrbrush_key]["corrbrush_sigmabrush"].extent([sigmaFactor-0.1,sigmaFactor+0.1]);
//      console.log("sigmabrush.selected",d3.select(".estcorrbrush_sigmaslider_"+corrbrush_key));
//      corrBrushes[corrbrush_key]["corrbrush_sigmabrush"](d3.select(".estcorrbrush_sigmaslider_"+corrbrush_key).transition());
//      corrBrushes[corrbrush_key]["corrbrush_sigmabrush"].event(d3.select(".estcorrbrush_sigmaslider_"+corrbrush_key).transition().delay(300));
//      corrBrushes[corrbrush_key]["corrbrush_sigmabrushed"] = sigma_;
//      console.log("key_,value", key_,corrBrushes[corrbrush_key]["corrbrush_sigmabrushed"]);
//      var musigma = estcorr_estimateMuSigma(corrbrush_key);
//      applyCorrbrushBySigmaSlider(corrbrush_key, dimensions[dimIdx-1], dimensions[dimIdx], musigma.mu, Math.sqrt(musigma.variance) );

    }



    var actives = dimensions.filter(function(p) { var brush_ = y[p]["brushes"][0]; return !brush_.empty(); }),
      extents = actives.map(function(p) { var brush_ = y[p]["brushes"][0]; return brush_.extent(); });
    foreground.style("display", function(d) {
      return actives.every(function(p, i) {
          console.log("change.color.fg.bg,",extents[i][0],extents[i][1]);
        return extents[i][0] <= d[p] && d[p] <= extents[i][1];
      }) ? null : "none";
    });
  }




  function estcorr_brushstart() {
    if (d3.event.sourceEvent===undefined || d3.event.sourceEvent===null)
      return;
    if (d3.event.sourceEvent.stopPropagation===undefined || d3.event.sourceEvent.stopPropagation===null)
      return;

    d3.event.sourceEvent.stopPropagation();
  }

  function estcorr_estimateMuVariance(key_){

//    //find mean and var of second correlated variable
//    //kevin murphy page 111.
//
    var ex = corrBrushes[key_]["corrbrush"].extent();
    ex = (ex[0]+ex[1]) / 2.0;

    var m1 = dimscales[key_].xscale(estcorr_remote_data.eigens[key_].m1);
    var m2 = dimscales[key_].yscale(estcorr_remote_data.eigens[key_].m2);
    var cov = estcorr_remote_data.eigens[key_].cov;
    var invcov = estcorr_remote_data.eigens[key_].invcov;

    var newm1 = ex;
    var newm2 = m2+cov[0][1]*(1./cov[0][0])*(newm1-m1);
    var newm2_origscale = dimscales[key_].ryscale(newm2);
    var variance = cov[1][1] -  cov[0][1]*(1./cov[0][0])*cov[1][0];

    return {"mu":newm2_origscale, "variance":variance};
  }

  function estcorr_brushed() {
      var clazz = $(this).attr("class");
      var key_ = clazz.substring("estcorrbrush_slider_".length);
      var localDims = key_.split("___");

      //estcorr_remote_data.eigens[key_]
    var ex = corrBrushes[key_]["corrbrush"].extent();
    ex = (ex[0]+ex[1]) / 2.0;
    corrBrushes[key_]["corrbrush_panel"]
      .selectAll(".estcorrvertpath")
      //.data([{"x":ex,"y":0}, {"x":ex,"y":0.5}])
      //.append("path")
      .attr("class", "estcorrvertpath")
      .attr("stroke", "blue")
      .attr("stroke-width", 0.5)
      .attr("fill", "none")
      .attr("d", estcorr_path([{"x":ex,"y":-1}, {"x":ex,"y":1}]))
    ;

    var muvar = estcorr_estimateMuVariance(key_);
    var sigma_ = Math.sqrt(muvar.variance);
    applyCorrbrush(key_,localDims[0], localDims[1],muvar.mu, sigma_);
  }


  function applyCorrbrush(key_,dim1,dim2, brush_mean, sigma) {
    //sigma, 2*sigma=95%
    var dim = dim2;
    var ex_r = brush_mean;
    var sigmaFactor = +corrBrushes[key_]["corrbrush_sigmabrushed"];

    var ex_ = [ex_r-sigmaFactor*sigma, ex_r+sigmaFactor*sigma];
    (y[dim].brushes[0]).extent(ex_);
    (y[dim].brushes[0])(d3.select(".dimension_"+dim).select(".brush").transition());
    (y[dim].brushes[0]).event(d3.select(".dimension_"+dim).select(".brush").transition().delay(300));

  }


  function applyCorrbrushBySigmaSlider(key_,dim1,dim2, brush_mean, sigma) {
    //sigma, 2*sigma=95%
    var dim = dim2;
    var ex_r = brush_mean;
    var sigmaFactor = +corrBrushes[key_]["corrbrush_sigmabrushed"];

    var ex_ = [ex_r-sigmaFactor*sigma, ex_r+sigmaFactor*sigma];
    (y[dim].brushes[0]).extent(ex_);
    (y[dim].brushes[0])(d3.select(".dimension_"+dim).select(".brush").transition());
    (y[dim].brushes[0]).event(d3.select(".dimension_"+dim).select(".brush").transition().delay(300));
  }


  // Returns the path for a given data point.
  function estcorr_path(d) {

    //var dims_ = [estcorr_xscale(d[0]) , estcorr_yscale(d[1])];
    //let line_ =  estcorr_line(dims_);

    line_ =  estcorr_line(d);
    return line_;
  }




  function sigmaSlider_brushed(){

    var clazz = $(this).attr("class");
    var key_ = clazz.substring("estcorrbrush_sigmaslider_".length);
    var localDims = key_.split("___");

    //estcorr_remote_data.eigens[key_]
    var ex = corrBrushes[key_]["corrbrush_sigmabrush"].extent();
    var sigmaFactor_ = (ex[0]+ex[1])/2.0;
    corrBrushes[key_]["corrbrush_sigmabrushed"] = sigmaFactor_;
    var muvar = estcorr_estimateMuVariance(key_);
    applyCorrbrushBySigmaSlider(key_, localDims[0], localDims[1], muvar.mu, Math.sqrt(muvar.variance) );
  }

  //searches for the count of brushes in the dim, determine the the count of brushes and return count+1
  function dimension_nextBrushIdx(dim){
      //class format dimension_brush_dimname_idx
    var idx=-1;//no brush for that dim
      for (var i=10;i>=1;i--){
          var obj = $(".dimension_brush_"+dim+"_"+i).length;
          console.log("obj",obj);
          if (obj!=0){
              idx=i;
              break;
          }
      }

      if (idx!=-1){ //a brush found. idx indicate the number of brushes. return idx+1 as new brush_idx
          return idx+1;
      }
      //return 1 as new idx, which is initial idx.
      return 1;
  }

  function start(data_){
    estcorr_remote_data = data_;
    var data = data_.csv;
    var eigens = data_.eigens;




  svg.on("mousedown", function() {
      var target = d3.event.target || d3.event.srcElement;
      console.log("svg.mousedown", target);
    }).on("brush", function() {
    var target = d3.event.target || d3.event.srcElement;
    console.log("svg.dragstart", target);
  })
      .on("mousemove", function() {
        var target = d3.event.target || d3.event.srcElement;
        if (!target) return;
//        if ( target === svg.rect() ) {
//          /* Brush */
//        } else {
//          var mouse = d3.mouse(svg.node());
//          target.attr({x: mouse[0], y: mouse[1]});
//        }
        //console.log("svg.mousemove", target);
      });



    // Extract the list of dimensions and create a scale for each.
    x.domain(dimensions = d3.keys(data[0]).filter(function(d) {
      return d != "name" && (y[d] = d3.scale.linear()
          .domain(d3.extent(data, function(p) { return +p[d]; }))
          .range([height, 0]));
    }));

    for (var i=0;i<dimensions.length;i++){
      if (! ( (i+1)<dimensions.length))
        break;
        var d = dimensions[i];
        var key_ = dimensions[i]+"___"+dimensions[i+1];
        var x_extent = eigens[key_].extents[0];
        var y_extent = eigens[key_].extents[1];
      dimscales[key_] = {
          "xscale":d3.scale.linear().domain(x_extent).range([-0.999, 0.999]),
          "rxscale":d3.scale.linear().domain([-0.999, 0.999]).range(x_extent),
          "yscale":d3.scale.linear().domain(y_extent).range([-0.999, 0.999]),
          "ryscale":d3.scale.linear().domain([-0.999, 0.999]).range(y_extent),

      };
    }



    // Add grey background lines for context.
    background = svg.append("g")
      .attr("class", "background")
      .selectAll("path")
      .data(data)
      .enter().append("path")
      .attr("d", path);

    // Add blue foreground lines for focus.
    foreground = svg.append("g")
      .attr("class", "foreground")
      .selectAll("path")
      .data(data)
      .enter().append("path")
      .attr("d", path);

    // Add a group element for each dimension.
    var g = svg.selectAll(".dimension")
      .data(dimensions)
      .enter().append("g")
      .attr("class", (d)=>"dimension dimension_"+d)
      .attr("transform", function(d) { return "translate(" + x(d) + ")"; })
     ;

    // Add an axis and title.
    g.append("g")
      .attr("class", (d)=>"axis axis_"+d)
      .each(function(d) { d3.select(this).call(axis.scale(y[d])); })
      .append("text")
      .style("text-anchor", "middle")
      .attr("y", -9)
      .text(function(d) { return d; });

    // Add and store a brush for each axis.
    g.append("g")
      .attr("class", function(d) { return "brush dimension_brush_"+d+"_"+dimension_nextBrushIdx(d);})
      .each(function(d) {
        //multi-brushes
        y[d]["brushes"]=[];
        var brush_ = d3.svg.brush().y(y[d]).on("brushstart", brushstart).on("brush", brush).on("brushend",brushend);
        y[d].brushes.push( brush_);
        d3.select(this).call(y[d].brushes[0]);

      })
      .selectAll("rect")
      .attr("x", -8)
      .attr("width", 16);


    // Add estcorrbrush

    for (var i=0;i<dimensions.length;i++){
      if (! ( (i+1)<dimensions.length))
        break;

      var d = dimensions[i];
      var key_ = dimensions[i]+"___"+dimensions[i+1];
      corrBrushes[key_]={};
      corrBrushes[key_]["corrbrush_panel"] = svg.selectAll(".estcorrbrush_panel_"+key_)
        .data([0]).enter().append("g")
        .attr("class", "estcorrbrush_panel_"+key_)
        .attr("transform", function(){return "translate(" + [(x(dimensions[i])+50),height+10] + ")"; })
        ;

      corrBrushes[key_]["corrbrush_panel"].append("rect")
        .attr("y", 0)
        .attr("width", 70)
        .attr("height", 70)
        .attr("fill", "#eeeeee");


      corrBrushes[key_]["corrbrush_sigma_panel"] = svg.selectAll(".estcorrbrush_sigmapanel_"+key_)
        .data([0]).enter().append("g")
        .attr("class", "estcorrbrush_sigmapanel_"+key_)
        .attr("transform", function(){return "translate(" + [(x(dimensions[i])+50),height+90] + ")"; })
      ;
      corrBrushes[key_]["corrbrush_sigma_panel"].append("rect")
        .attr("y", 0)
        .attr("width", 70)
        .attr("height", 10)
        .attr("fill", "yellow");


    }

    for (var i=0;i<dimensions.length;i++){
      if (! ( (i+1)<dimensions.length))
        break;
      var d = dimensions[i];
      var key_ = dimensions[i]+"___"+dimensions[i+1];
      corrBrushes[key_]["corrbrush"] = d3.svg.brush().x(estcorr_xscale);
      corrBrushes[key_]["corrbrush"].on("brushstart", estcorr_brushstart).on("brush", estcorr_brushed);

      //corrbrush slider
      var slider = corrBrushes[key_]["corrbrush_panel"].append("g")
          .attr("class", "estcorrbrush_slider_"+key_)
        .attr("transform", "translate("+ [0,65]+")")
        ;
      corrBrushes[key_]["corrbrush"].extent([-0.1,0.1]);
      corrBrushes[key_]["corrbrush"](slider);
      //slider.selectAll("rect.background").attr("height", 300);
      slider.selectAll("rect.extent").attr("height", 10);
      slider.selectAll("rect.extent").attr("width", 10 );
      slider.selectAll(".resize rect").attr("height", 0);



      //sigma slider
      corrBrushes[key_]["corrbrush_sigmabrush"] =   d3.svg.brush().x(sigmaSlider_xScale);
      corrBrushes[key_]["corrbrush_sigmabrush"].on("brushstart", brushstart).on("brush",sigmaSlider_brushed);

      var sigmaSlider = corrBrushes[key_]["corrbrush_sigma_panel"].append("g")
          .attr("class", "estcorrbrush_sigmaslider_"+key_)
        .attr("transform", "translate("+ [0,0]+")")
      ;


      corrBrushes[key_]["corrbrush_sigma_panel"]
        .append("g")
        .attr("class", "axis")
        .call(sigmaSlider_axis)
      ;

      corrBrushes[key_]["corrbrush_sigmabrush"].extent([1,1.4]);
      corrBrushes[key_]["corrbrush_sigmabrush"](sigmaSlider);
      corrBrushes[key_]["corrbrush_sigmabrushed"] = 1.2; //mean of a and 1.4
      //slider.selectAll("rect.background").attr("height", 300);
      sigmaSlider.selectAll("rect.extent").attr("height", 10);
      sigmaSlider.selectAll("rect.extent").attr("width", 10 );
      sigmaSlider.selectAll(".resize rect").attr("height", 0);


      corrBrushes[key_]["corrbrush_panel"]
      //.selectAll(".estcorrvertpath")
      //.data([{"x":ex,"y":0}, {"x":ex,"y":0.5}])
        .append("path")
        .attr("class", "estcorrvertpath")
        .attr("stroke", "blue")
        .attr("stroke-width", 0.5)
        .attr("fill", "none")
        .attr("d", estcorr_path([{"x":0,"y":-1}, {"x":0,"y":1}]))
      ;
    }



    for (var i=0;i<dimensions.length;i++) {
        if (! ( (i+1)<dimensions.length))
            break;
      var d = dimensions[i];
      var key_ = dimensions[i]+"___"+dimensions[i+1];
      corrBrushes[key_]["corrbrush_panel"].selectAll(".estcorrbrush_ellipse_"+d)
        .data([0]).enter()
        .append("ellipse")
        .attr("class", "estcorrbrush_ellipse_"+d)
        .attr("cx", estcorr_xscale(0))
        .attr("cy", estcorr_yscale(0))
        .attr("rx", estcorr_rscale(eigens[key_].eigvals[0]/2))
        .attr("ry", estcorr_rscale(eigens[key_].eigvals[1]/2))
        .attr("fill", "none")
        .attr("stroke", "#000")
        .attr("transform", (d, i) => {
          return "rotate(" + (-1 * 1 * eigens[key_].angle) + "," + estcorr_xscale(0) + "," + estcorr_yscale(0) + ")"
        });
    }



  }


  $().ready(function(){

    $.getJSON( "http://localhost:5000/proghist/parallelcoord/iriscorr/fetchData", function( data_ ) {
      start(data_);
    });

    $("#sepal_w_brush_btn").click(function(){
        //applyCorrbrush("petal_len", 3.2);
    });

  });

</script>
